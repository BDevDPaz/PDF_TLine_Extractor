#extractor_V6.py
import sqlite3
import pdfplumber
import re
import os
from datetime import datetime
import traceback

DB_FILE = "timeline.db"

def inicializar_db(db_path=DB_FILE):
    """Crea la tabla de eventos si no existe."""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS eventos (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            archivo_origen TEXT NOT NULL,
            linea_asociada TEXT NOT NULL,
            fecha_evento TEXT,
            hora_evento TEXT,
            tipo_evento TEXT,
            direccion TEXT,
            destino TEXT,
            duracion_cantidad TEXT,
            descripcion_completa TEXT
        )
    ''')
    conn.commit()
    conn.close()

def _parse_line_for_event(linea, fecha_actual_str, seccion_actual, linea_actual, nombre_archivo):
    """
    Intenta extraer un evento de una línea de texto.
    Versión robusta que maneja todos los casos para ENTRANTE y SALIENTE.
    """
    match_hora = re.search(r'(\d{1,2}:\d{2})\s*(AM|PM)?', linea)
    if not match_hora or not fecha_actual_str or seccion_actual == "Desconocida":
        return None

    hora = match_hora.group(0).strip()
    tipo = seccion_actual
    direccion, destino, duracion_cantidad = "N/A", "N/A", "N/A"

    if tipo == "LLAMADA":
        # --- LÓGICA DE DIRECCIÓN COMPLETA RESTAURADA ---
        if "Incoming" in linea or " IN " in linea:
            direccion = "ENTRANTE"
        elif "OUT" in linea or re.search(r'\bto\s+[A-Za-z\s]+/[A-Z]{2}', linea):
            direccion = "SALIENTE"
        
        match_destino = re.search(r'(\(\d{3}\)\s\d{3}-\d{4})|VM Retrieval', linea)
        if match_destino:
            destino = match_destino.group(0)
            if "VM Retrieval" in destino:
                direccion = "SALIENTE"
        
        parts = linea.split()
        if parts:
            for part in reversed(parts):
                cleaned_part = re.sub(r'[^\d.-]', '', part).strip('-.')
                if cleaned_part and cleaned_part.isdigit():
                    duracion_cantidad = cleaned_part
                    break

    elif tipo == "TEXTO/MMS":
        if "Incoming" in linea or " IN " in linea:
            direccion = "ENTRANTE"
        elif "OUT" in linea or re.search(r'\bto\s+[A-Za-z\s]+/[A-Z]{2}', linea):
            direccion = "SALIENTE"
            
        match_destino = re.search(r'(\(\d{3}\)\s\d{3}-\d{4}|\d{5,})', linea)
        if match_destino:
            destino = match_destino.group(0)
        duracion_cantidad = "1"
    
    if direccion == "N/A" and destino != "N/A":
        direccion = "SALIENTE"

    return (
        nombre_archivo, linea_actual, fecha_actual_str, hora,
        tipo, direccion, destino, duracion_cantidad, linea
    )

def procesar_pdf(ruta_archivo, db_path=DB_FILE):
    """
    Versión final que combina un estado persistente con una lectura de texto ordenada
    para garantizar tanto la precisión de los datos como el orden cronológico.
    """
    nombre_archivo = os.path.basename(ruta_archivo)
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    eventos_a_insertar = []

    try:
        with pdfplumber.open(ruta_archivo) as pdf:
            texto_primera_pagina = pdf.pages[0].extract_text(x_tolerance=2) or ""
            match_anual = re.search(r'Bill issue date.*?(\b20\d{2}\b)', texto_primera_pagina, re.DOTALL)
            bill_year = int(match_anual.group(1)) if match_anual else datetime.now().year

            fecha_actual_str = None
            seccion_actual = "Desconocida"
            linea_actual = "Desconocida"

            for page in pdf.pages[3:]:
                # Usar una extracción de texto que respeta el orden de lectura natural
                texto_pagina = page.extract_text(x_tolerance=2, layout=True)
                if not texto_pagina:
                    continue
                
                # Actualizar el estado (sección, línea) basado en el contenido de la página
                if "TALK" in texto_pagina: seccion_actual = "LLAMADA"
                elif "TEXT" in texto_pagina: seccion_actual = "TEXTO/MMS"
                elif "DATA" in texto_pagina: seccion_actual = "DATOS"
                
                match_linea_header = re.search(r'(\(\d{3}\)\s\d{3}-\d{4})', texto_pagina)
                if match_linea_header:
                    linea_actual = match_linea_header.group(1)

                for linea in texto_pagina.split('\n'):
                    linea_texto = linea.strip()

                    if not linea_texto or "CONTINUED" in linea_texto or "TOTALS" in linea_texto or "Description" in linea_texto:
                        continue

                    match_fecha = re.search(r'^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{1,2})', linea_texto, re.IGNORECASE)
                    if match_fecha:
                        try:
                            fecha_obj = datetime.strptime(f"{match_fecha.group(0)} {bill_year}", "%b %d %Y")
                            fecha_actual_str = fecha_obj.strftime("%Y-%m-%d")
                        except ValueError:
                            pass
                    
                    evento = _parse_line_for_event(linea_texto, fecha_actual_str, seccion_actual, linea_actual, nombre_archivo)
                    if evento:
                        eventos_a_insertar.append(evento)

        if not eventos_a_insertar:
            return (False, "No se encontraron eventos válidos en las páginas de detalle.", 0)

        cursor.executemany(
            'INSERT INTO eventos (archivo_origen, linea_asociada, fecha_evento, hora_evento, tipo_evento, direccion, destino, duracion_cantidad, descripcion_completa) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
            eventos_a_insertar
        )
        
        eventos_guardados = len(eventos_a_insertar)
        return (True, "Archivo procesado correctamente.", eventos_guardados)

    except Exception as e:
        error_details = traceback.format_exc()
        return (False, f"Ocurrió un error inesperado: {str(e)}", 0)
    finally:
        if conn:
            conn.commit()
            conn.close()

#extractor_V5.py
import sqlite3
import pdfplumber
import re
import os
from datetime import datetime
import traceback

DB_FILE = "timeline.db"

def inicializar_db(db_path=DB_FILE):
    """Crea la tabla de eventos si no existe."""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS eventos (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            archivo_origen TEXT NOT NULL,
            linea_asociada TEXT NOT NULL,
            fecha_evento TEXT,
            hora_evento TEXT,
            tipo_evento TEXT,
            direccion TEXT,
            destino TEXT,
            duracion_cantidad TEXT,
            descripcion_completa TEXT
        )
    ''')
    conn.commit()
    conn.close()

def _parse_line_for_event(linea, fecha_actual_str, seccion_actual, linea_actual, nombre_archivo):
    """
    Intenta extraer un evento de una línea de texto.
    Versión robusta que maneja todos los casos para ENTRANTE y SALIENTE.
    """
    match_hora = re.search(r'(\d{1,2}:\d{2})\s*(AM|PM)?', linea)
    if not match_hora or not fecha_actual_str or seccion_actual == "Desconocida":
        return None

    hora = match_hora.group(0).strip()
    tipo = seccion_actual
    direccion, destino, duracion_cantidad = "N/A", "N/A", "N/A"

    if tipo == "LLAMADA":
        # --- LÓGICA DE DIRECCIÓN COMPLETA RESTAURADA ---
        if "Incoming" in linea or " IN " in linea:
            direccion = "ENTRANTE"
        elif "OUT" in linea or re.search(r'\bto\s+[A-Za-z\s]+/[A-Z]{2}', linea):
            direccion = "SALIENTE"
        
        match_destino = re.search(r'(\(\d{3}\)\s\d{3}-\d{4})|VM Retrieval', linea)
        if match_destino:
            destino = match_destino.group(0)
            if "VM Retrieval" in destino:
                direccion = "SALIENTE"
        
        parts = linea.split()
        if parts:
            for part in reversed(parts):
                cleaned_part = re.sub(r'[^\d.-]', '', part).strip('-.')
                if cleaned_part and cleaned_part.isdigit():
                    duracion_cantidad = cleaned_part
                    break

    elif tipo == "TEXTO/MMS":
        if "Incoming" in linea or " IN " in linea:
            direccion = "ENTRANTE"
        elif "OUT" in linea or re.search(r'\bto\s+[A-Za-z\s]+/[A-Z]{2}', linea):
            direccion = "SALIENTE"
            
        match_destino = re.search(r'(\(\d{3}\)\s\d{3}-\d{4}|\d{5,})', linea)
        if match_destino:
            destino = match_destino.group(0)
        duracion_cantidad = "1"
    
    if direccion == "N/A" and destino != "N/A":
        direccion = "SALIENTE"

    return (
        nombre_archivo, linea_actual, fecha_actual_str, hora,
        tipo, direccion, destino, duracion_cantidad, linea
    )

def procesar_pdf(ruta_archivo, db_path=DB_FILE):
    """
    Versión final que combina un estado persistente con una lectura de texto ordenada
    para garantizar tanto la precisión de los datos como el orden cronológico.
    """
    nombre_archivo = os.path.basename(ruta_archivo)
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    eventos_a_insertar = []

    try:
        with pdfplumber.open(ruta_archivo) as pdf:
            texto_primera_pagina = pdf.pages[0].extract_text(x_tolerance=2) or ""
            match_anual = re.search(r'Bill issue date.*?(\b20\d{2}\b)', texto_primera_pagina, re.DOTALL)
            bill_year = int(match_anual.group(1)) if match_anual else datetime.now().year

            fecha_actual_str = None
            seccion_actual = "Desconocida"
            linea_actual = "Desconocida"

            for page in pdf.pages[3:]:
                # Usar una extracción de texto que respeta el orden de lectura natural
                texto_pagina = page.extract_text(x_tolerance=2, layout=True)
                if not texto_pagina:
                    continue
                
                # Actualizar el estado (sección, línea) basado en el contenido de la página
                if "TALK" in texto_pagina: seccion_actual = "LLAMADA"
                elif "TEXT" in texto_pagina: seccion_actual = "TEXTO/MMS"
                elif "DATA" in texto_pagina: seccion_actual = "DATOS"
                
                match_linea_header = re.search(r'(\(\d{3}\)\s\d{3}-\d{4})', texto_pagina)
                if match_linea_header:
                    linea_actual = match_linea_header.group(1)

                for linea in texto_pagina.split('\n'):
                    linea_texto = linea.strip()

                    if not linea_texto or "CONTINUED" in linea_texto or "TOTALS" in linea_texto or "Description" in linea_texto:
                        continue

                    match_fecha = re.search(r'^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{1,2})', linea_texto, re.IGNORECASE)
                    if match_fecha:
                        try:
                            fecha_obj = datetime.strptime(f"{match_fecha.group(0)} {bill_year}", "%b %d %Y")
                            fecha_actual_str = fecha_obj.strftime("%Y-%m-%d")
                        except ValueError:
                            pass
                    
                    evento = _parse_line_for_event(linea_texto, fecha_actual_str, seccion_actual, linea_actual, nombre_archivo)
                    if evento:
                        eventos_a_insertar.append(evento)

        if not eventos_a_insertar:
            return (False, "No se encontraron eventos válidos en las páginas de detalle.", 0)

        cursor.executemany(
            'INSERT INTO eventos (archivo_origen, linea_asociada, fecha_evento, hora_evento, tipo_evento, direccion, destino, duracion_cantidad, descripcion_completa) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
            eventos_a_insertar
        )
        
        eventos_guardados = len(eventos_a_insertar)
        return (True, "Archivo procesado correctamente.", eventos_guardados)

    except Exception as e:
        error_details = traceback.format_exc()
        return (False, f"Ocurrió un error inesperado: {str(e)}", 0)
    finally:
        if conn:
            conn.commit()
            conn.close()

#extractor_V4.py
import sqlite3
import pdfplumber
import re
import os
from datetime import datetime
import traceback

DB_FILE = "timeline.db"

def inicializar_db(db_path=DB_FILE): # <-- CAMBIO AQUÍ
    """Crea la tabla de eventos si no existe."""
    conn = sqlite3.connect(db_path) # <-- CAMBIO AQUÍ
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS eventos (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            archivo_origen TEXT NOT NULL,
            linea_asociada TEXT NOT NULL,
            fecha_evento TEXT,
            hora_evento TEXT,
            tipo_evento TEXT,
            direccion TEXT,
            destino TEXT,
            duracion_cantidad TEXT,
            descripcion_completa TEXT
        )
    ''')
    conn.commit()
    conn.close()

# VvV CAMBIO AQUÍ EN LA DEFINICIÓN DE LA FUNCIÓN vVv
def procesar_pdf(ruta_archivo, db_path=DB_FILE):
    """
    Versión final que integra las mejoras clave en la lógica del código original
    para asegurar la correcta extracción de datos en orden cronológico.
    """
    nombre_archivo = os.path.basename(ruta_archivo)
    conn = sqlite3.connect(db_path) # <-- CAMBIO AQUÍ
    cursor = conn.cursor()
    
    eventos_guardados = 0
    linea_actual = "Desconocida"
    fecha_actual_str = None
    seccion_actual = "Desconocida"

    try:
        with pdfplumber.open(ruta_archivo) as pdf:
            texto_primera_pagina = pdf.pages[0].extract_text(x_tolerance=2) or ""
            match_anual = re.search(r'Bill issue date.*?(\b20\d{2}\b)', texto_primera_pagina, re.DOTALL)
            bill_year = int(match_anual.group(1)) if match_anual else datetime.now().year
            print(f"INFO: Año de la factura detectado: {bill_year}")

            for page in pdf.pages[3:]:
                print(f"\n--- Procesando Página {page.page_number + 1} ---")
                
                words = page.extract_words(keep_blank_chars=True, x_tolerance=2)
                if not words: continue

                lines = {}
                for w in words:
                    line_top = round(w["top"])
                    if line_top not in lines:
                        lines[line_top] = []
                    lines[line_top].append(w)
                
                sorted_lines = sorted(lines.items())
                
                left_column_text, right_column_text = [], []
                page_center = page.width / 2

                for _, words_in_line in sorted_lines:
                    line_text = "".join(w["text"] for w in words_in_line).strip()
                    if not line_text: continue
                    
                    is_header = False
                    if "CONTINUED" in line_text or any(h in line_text for h in ["TALK", "TEXT", "DATA"]):
                        is_header = True
                        match_linea = re.search(r'(\(\d{3}\)\s\d{3}-\d{4})', line_text)
                        if match_linea:
                            linea_actual = match_linea.group(1)
                            print(f"INFO: Línea telefónica actualizada a: {linea_actual}")
                        if "TALK" in line_text: seccion_actual = "LLAMADA"
                        if "TEXT" in line_text: seccion_actual = "TEXTO/MMS"
                        if "DATA" in line_text: seccion_actual = "DATOS"
                        if seccion_actual != "Desconocida":
                             print(f"INFO: Sección actualizada a: {seccion_actual}")
                    
                    if is_header: continue
                        
                    avg_x = sum(w["x0"] for w in words_in_line) / len(words_in_line)
                    if avg_x < page_center:
                        left_column_text.append(line_text)
                    else:
                        right_column_text.append(line_text)
                
                for columna_texto in [left_column_text, right_column_text]:
                    for linea in columna_texto:
                        match_fecha = re.search(r'^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{1,2})', linea, re.IGNORECASE)
                        if match_fecha:
                            try:
                                fecha_obj = datetime.strptime(f"{match_fecha.group(0)} {bill_year}", "%b %d %Y")
                                fecha_actual_str = fecha_obj.strftime("%Y-%m-%d")
                            except ValueError: pass
                        
                        if not fecha_actual_str: continue

                        match_hora = re.search(r'(\d{1,2}:\d{2})\s*(AM|PM)?', linea)
                        if not match_hora: continue
                        
                        hora = match_hora.group(0).strip()
                        tipo = seccion_actual
                        direccion, destino, duracion_cantidad = "N/A", "N/A", "N/A"

                        if tipo == "LLAMADA":
                            if "Incoming" in linea or " IN " in linea: direccion = "ENTRANTE"
                            elif "OUT" in linea: direccion = "SALIENTE"
                            match_destino = re.search(r'(\(\d{3}\)\s\d{3}-\d{4})', linea)
                            if match_destino: destino = match_destino.group(0)
                            numeros_en_fila = re.findall(r'\b(\d+)\b', linea)
                            if numeros_en_fila: duracion_cantidad = numeros_en_fila[-1]

                        elif tipo == "TEXTO/MMS":
                            if "Incoming" in linea or " IN " in linea: direccion = "ENTRANTE"
                            elif "OUT" in linea: direccion = "SALIENTE"
                            match_destino = re.search(r'(\(\d{3}\)\s\d{3}-\d{4}|\d{10,}|1022)', linea)
                            if match_destino: destino = match_destino.group(0)
                            duracion_cantidad = "1"
                        
                        elif tipo == "DATOS":
                            pass

                        cursor.execute(
                            'INSERT INTO eventos (archivo_origen, linea_asociada, fecha_evento, hora_evento, tipo_evento, direccion, destino, duracion_cantidad, descripcion_completa) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
                            (nombre_archivo, linea_actual, fecha_actual_str, hora, tipo, direccion, destino, duracion_cantidad, linea)
                        )
                        eventos_guardados += 1

        if eventos_guardados == 0:
            return (False, "No se encontraron eventos en la sección 'USAGE DETAILS'.", 0)

        print(f"\nProceso finalizado. Total de eventos encontrados: {eventos_guardados}")
        return (True, "Archivo procesado correctamente.", eventos_guardados)

    except Exception as e:
        error_details = traceback.format_exc()
        print(f"Ocurrió un error inesperado: {str(e)}\n{error_details}")
        return (False, f"Ocurrió un error inesperado: {str(e)}", 0)
    finally:
        if conn:
            conn.commit()
            conn.close()

#extractor_V3.py
import sqlite3
import pdfplumber
import re
import os
from datetime import datetime

DB_FILE = "timeline.db"

def inicializar_db():
    """Crea la tabla de eventos si no existe, incluyendo la nueva columna."""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS eventos (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            archivo_origen TEXT NOT NULL,
            linea_asociada TEXT NOT NULL,
            fecha_evento TEXT,
            hora_evento TEXT,
            tipo_evento TEXT,
            direccion TEXT,
            destino TEXT,
            descripcion TEXT,
            duracion_cantidad TEXT 
        )
    ''')
    try:
        cursor.execute("SELECT duracion_cantidad FROM eventos LIMIT 1")
    except sqlite3.OperationalError:
        print("Añadiendo columna 'duracion_cantidad' a la base de datos existente.")
        cursor.execute("ALTER TABLE eventos ADD COLUMN duracion_cantidad TEXT")
    conn.commit()
    conn.close()

def procesar_pdf(ruta_archivo):
    """
    Versión con lógica de extracción de duración corregida.
    """
    nombre_archivo = os.path.basename(ruta_archivo)
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    linea_actual = "Desconocida"
    fecha_actual_str = "Desconocida"
    bill_year = None
    procesando_uso = False
    fecha_encontrada = False
    eventos_guardados = 0

    try:
        with pdfplumber.open(ruta_archivo) as pdf:
            texto_primera_pagina = pdf.pages[0].extract_text()
            match_anual = re.search(r'\b(20\d{2})\b', texto_primera_pagina)
            bill_year = int(match_anual.group(1)) if match_anual else datetime.now().year

            for i, pagina in enumerate(pdf.pages):
                texto_pagina = pagina.extract_text(x_tolerance=2, y_tolerance=2) or ""

                if "USAGE DETAILS" in texto_pagina and not procesando_uso:
                    procesando_uso = True

                if not procesando_uso:
                    continue
                
                match_linea = re.search(r'(\(\d{3}\) \d{3}-\d{4})', texto_pagina)
                if match_linea:
                    linea_actual = match_linea.group(1)

                tablas = pagina.extract_tables({"vertical_strategy": "text", "horizontal_strategy": "text"})
                if not tablas: continue

                for tabla in tablas:
                    if not tabla: continue
                    for fila in tabla:
                        if not fila: continue
                        
                        fila_str = ' '.join(filter(None, [item.replace('\n', ' ') if item else '' for item in fila])).strip()
                        
                        match_fecha = re.search(r'(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2}', fila_str)
                        if match_fecha:
                            fecha_encontrada = True
                            fecha_texto = match_fecha.group(0)
                            try:
                                fecha_obj = datetime.strptime(f"{fecha_texto} {bill_year}", "%b %d %Y")
                                fecha_actual_str = fecha_obj.strftime("%Y-%m-%d")
                            except ValueError:
                                fecha_actual_str = fecha_texto
                        
                        if not fecha_encontrada:
                            continue

                        match_hora = re.search(r'(\d{1,2}:\d{2}\s(?:AM|PM))', fila_str)
                        if not match_hora:
                            continue
                        
                        hora = match_hora.group(0)
                        
                        tipo = "EVENTO"
                        if "to " in fila_str and ("CA" in fila_str or "WA" in fila_str or "NV" in fila_str): tipo = "LLAMADA"
                        elif "Incoming" in fila_str: tipo = "LLAMADA"
                        elif "VM Retrieval" in fila_str: tipo = "LLAMADA"
                        elif "TXT" in fila_str.upper() or "PIC" in fila_str.upper(): tipo = "TEXTO/MMS"
                        elif "DATA" in fila_str.upper() or "Mobile" in fila_str or "Web" in fila_str: tipo = "DATOS"

                        direccion = "N/A"
                        if " IN " in fila_str or "Incoming" in fila_str: direccion = "ENTRANTE"
                        elif "OUT" in fila_str: direccion = "SALIENTE"
                        
                        destino = "N/A"
                        match_destino = re.search(r'(\(\d{3}\)\s\d{3}-\d{4}|\d{10}|\d{5})', fila_str)
                        if match_destino: destino = match_destino.group(0)
                        
                        ### CORRECCIÓN: Lógica mejorada para extraer duración ###
                        duracion_cantidad = "N/A"
                        if tipo == "LLAMADA":
                            # Se itera hacia atrás sobre los elementos de la fila.
                            # El primer elemento que sea puramente numérico es la duración.
                            for item in reversed(fila):
                                if item and item.strip().isdigit():
                                    duracion_cantidad = item.strip()
                                    break 
                        elif tipo == "TEXTO/MMS":
                            duracion_cantidad = "1"

                        cursor.execute(
                            'INSERT INTO eventos (archivo_origen, linea_asociada, fecha_evento, hora_evento, tipo_evento, direccion, destino, descripcion, duracion_cantidad) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
                            (nombre_archivo, linea_actual, fecha_actual_str, hora, tipo, direccion, destino, fila_str, duracion_cantidad)
                        )
                        eventos_guardados += 1
        
        if eventos_guardados == 0:
             return (False, "No se encontraron eventos en la sección 'USAGE DETAILS'.", 0)

        return (True, "Archivo procesado correctamente.", eventos_guardados)

    except Exception as e:
        return (False, f"Ocurrió un error inesperado: {str(e)}", 0)
    finally:
        conn.commit()
        conn.close()

#extractor_V2.py
import sqlite3
import pdfplumber
import re
import os
from datetime import datetime

DB_FILE = "timeline.db"

def inicializar_db():
    """Crea la tabla de eventos si no existe."""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS eventos (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            archivo_origen TEXT NOT NULL,
            linea_asociada TEXT NOT NULL,
            fecha_evento TEXT,
            hora_evento TEXT,
            tipo_evento TEXT,
            direccion TEXT,
            destino TEXT,
            descripcion TEXT
        )
    ''')
    conn.commit()
    conn.close()

### OPTIMIZACIÓN ###
# La función ahora devuelve una tupla (success, message, count) para un mejor feedback.
def procesar_pdf(ruta_archivo):
    """
    Versión optimizada para feedback en la interfaz de usuario.
    - Devuelve una tupla (success, message, count).
    - Captura excepciones para reportar errores específicos.
    """
    nombre_archivo = os.path.basename(ruta_archivo)
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    linea_actual = "Desconocida"
    fecha_actual_str = "Desconocida"
    bill_year = None
    procesando_uso = False
    fecha_encontrada = False
    eventos_guardados = 0

    try:
        with pdfplumber.open(ruta_archivo) as pdf:
            # Lógica de detección de año
            texto_primera_pagina = pdf.pages[0].extract_text()
            match_anual = re.search(r'\b(20\d{2})\b', texto_primera_pagina)
            if match_anual:
                bill_year = int(match_anual.group(1))
            else:
                bill_year = datetime.now().year

            for i, pagina in enumerate(pdf.pages):
                num_pagina = i + 1
                texto_pagina = pagina.extract_text(x_tolerance=2, y_tolerance=2) or ""

                if "USAGE DETAILS" in texto_pagina and not procesando_uso:
                    procesando_uso = True

                if not procesando_uso:
                    continue
                
                match_linea = re.search(r'(\(\d{3}\) \d{3}-\d{4})', texto_pagina)
                if match_linea:
                    linea_actual = match_linea.group(1)

                table_settings = {"vertical_strategy": "text", "horizontal_strategy": "text"}
                tablas = pagina.extract_tables(table_settings)
                
                if not tablas: continue

                for tabla in tablas:
                    if not tabla: continue
                    for fila in tabla:
                        if not fila: continue
                        
                        fila_str = ' '.join(filter(None, [item.replace('\n', ' ') if item else '' for item in fila])).strip()
                        
                        match_fecha = re.search(r'(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2}', fila_str)
                        if match_fecha:
                            fecha_encontrada = True
                            fecha_texto = match_fecha.group(0)
                            try:
                                fecha_obj = datetime.strptime(f"{fecha_texto} {bill_year}", "%b %d %Y")
                                fecha_actual_str = fecha_obj.strftime("%Y-%m-%d")
                            except ValueError:
                                fecha_actual_str = fecha_texto
                        
                        if not fecha_encontrada:
                            continue

                        match_hora = re.search(r'(\d{1,2}:\d{2}\s(?:AM|PM))', fila_str)
                        if not match_hora:
                            continue
                        
                        hora = match_hora.group(0)
                        
                        tipo = "EVENTO"
                        if "to " in fila_str and ("CA" in fila_str or "WA" in fila_str or "NV" in fila_str): tipo = "LLAMADA"
                        elif "Incoming" in fila_str: tipo = "LLAMADA"
                        elif "TXT" in fila_str.upper() or "PIC" in fila_str.upper(): tipo = "TEXTO/MMS"
                        elif "DATA" in fila_str.upper() or "Mobile" in fila_str or "Web" in fila_str: tipo = "DATOS"

                        direccion = "N/A"
                        if " IN " in fila_str or "Incoming" in fila_str: direccion = "ENTRANTE"
                        elif "OUT" in fila_str: direccion = "SALIENTE"
                        
                        destino = "N/A"
                        match_destino = re.search(r'(\(\d{3}\)\s\d{3}-\d{4}|\d{10}|\d{5})', fila_str)
                        if match_destino: destino = match_destino.group(0)
                        
                        cursor.execute(
                            'INSERT INTO eventos (archivo_origen, linea_asociada, fecha_evento, hora_evento, tipo_evento, direccion, destino, descripcion) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
                            (nombre_archivo, linea_actual, fecha_actual_str, hora, tipo, direccion, destino, fila_str)
                        )
                        eventos_guardados += 1
        
        if eventos_guardados == 0:
             return (False, "El PDF es válido, pero no se encontraron eventos en la sección 'USAGE DETAILS'.", 0)

        return (True, "Archivo procesado correctamente.", eventos_guardados)

    except Exception as e:
        # Devuelve una tupla de fallo con el mensaje de error.
        return (False, f"Ocurrió un error inesperado: {str(e)}", 0)
    finally:
        # Asegura que la base de datos se cierre correctamente.
        conn.commit()
        conn.close()

#extractor_V1.py
import sqlite3
import pdfplumber
import re
import os
from datetime import datetime

DB_FILE = "timeline.db"

def inicializar_db():
    """Crea la tabla de eventos si no existe."""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS eventos (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            archivo_origen TEXT NOT NULL,
            linea_asociada TEXT NOT NULL,
            fecha_evento TEXT,
            hora_evento TEXT,
            tipo_evento TEXT,
            direccion TEXT,
            destino TEXT,
            descripcion TEXT
        )
    ''')
    conn.commit()
    conn.close()

def procesar_pdf(ruta_archivo):
    """
    Versión 7 (Definitiva):
    - Lógica de detección de año más robusta.
    - No procesa eventos hasta que se encuentra la primera fecha.
    """
    print(f"--- Iniciando procesamiento Definitivo para: {ruta_archivo} ---")
    nombre_archivo = os.path.basename(ruta_archivo)
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    linea_actual = "Desconocida"
    fecha_actual_str = "Desconocida"
    bill_year = None # Empezamos sin año
    procesando_uso = False
    fecha_encontrada = False # Flag para saber si ya hemos visto la primera fecha
    eventos_guardados = 0

    try:
        with pdfplumber.open(ruta_archivo) as pdf:
            # =================== LÓGICA DE AÑO MEJORADA ===================
            # Buscamos en la primera página cualquier número de 4 dígitos que parezca un año.
            texto_primera_pagina = pdf.pages[0].extract_text()
            match_anual = re.search(r'\b(20\d{2})\b', texto_primera_pagina)
            if match_anual:
                bill_year = int(match_anual.group(1))
                print(f"Año de la factura detectado: {bill_year}")
            else:
                bill_year = datetime.now().year # Si no se encuentra, usamos el año actual como último recurso.
                print(f"No se detectó el año, usando el actual: {bill_year}")
            # ===============================================================

            for i, pagina in enumerate(pdf.pages):
                num_pagina = i + 1
                texto_pagina = pagina.extract_text(x_tolerance=2, y_tolerance=2) or ""

                if "USAGE DETAILS" in texto_pagina and not procesando_uso:
                    procesando_uso = True
                    print(f"\n--- DETALLES DE USO ENCONTRADOS en página {num_pagina}. Iniciando extracción. ---")

                if not procesando_uso:
                    continue
                
                match_linea = re.search(r'(\(\d{3}\) \d{3}-\d{4})', texto_pagina)
                if match_linea:
                    linea_actual = match_linea.group(1)

                table_settings = {"vertical_strategy": "text", "horizontal_strategy": "text"}
                tablas = pagina.extract_tables(table_settings)
                
                if not tablas: continue

                for tabla in tablas:
                    if not tabla: continue
                    for fila in tabla:
                        if not fila: continue
                        
                        fila_str = ' '.join(filter(None, [item.replace('\n', ' ') if item else '' for item in fila])).strip()
                        
                        match_fecha = re.search(r'(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2}', fila_str)
                        if match_fecha:
                            fecha_encontrada = True # Activamos el flag al encontrar la primera fecha
                            fecha_texto = match_fecha.group(0)
                            try:
                                fecha_obj = datetime.strptime(f"{fecha_texto} {bill_year}", "%b %d %Y")
                                fecha_actual_str = fecha_obj.strftime("%Y-%m-%d")
                                print(f"    ** Nueva fecha procesada: {fecha_actual_str} **")
                            except ValueError:
                                fecha_actual_str = fecha_texto
                        
                        # Si aún no hemos encontrado la primera fecha, no procesamos la fila.
                        if not fecha_encontrada:
                            continue

                        match_hora = re.search(r'(\d{1,2}:\d{2}\s(?:AM|PM))', fila_str)
                        if not match_hora:
                            continue
                        
                        hora = match_hora.group(0)
                        
                        tipo = "EVENTO"
                        if "to " in fila_str and ("CA" in fila_str or "WA" in fila_str or "NV" in fila_str): tipo = "LLAMADA"
                        elif "Incoming" in fila_str: tipo = "LLAMADA"
                        elif "TXT" in fila_str.upper() or "PIC" in fila_str.upper(): tipo = "TEXTO/MMS"
                        elif "DATA" in fila_str.upper() or "Mobile" in fila_str or "Web" in fila_str: tipo = "DATOS"

                        direccion = "N/A"
                        if " IN " in fila_str or "Incoming" in fila_str: direccion = "ENTRANTE"
                        elif "OUT" in fila_str: direccion = "SALIENTE"
                        
                        destino = "N/A"
                        match_destino = re.search(r'(\(\d{3}\)\s\d{3}-\d{4}|\d{10}|\d{5})', fila_str)
                        if match_destino: destino = match_destino.group(0)
                        
                        cursor.execute(
                            'INSERT INTO eventos (archivo_origen, linea_asociada, fecha_evento, hora_evento, tipo_evento, direccion, destino, descripcion) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
                            (nombre_archivo, linea_actual, fecha_actual_str, hora, tipo, direccion, destino, fila_str)
                        )
                        eventos_guardados += 1
                        
    except Exception as e:
        print(f"!!!!!!!!!! OCURRIÓ UN ERROR GRAVE: {e} !!!!!!!!!!")
    finally:
        conn.commit()
        conn.close()
        print(f"\n--- Procesamiento finalizado. Total de eventos guardados: {eventos_guardados} ---")